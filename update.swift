import AppKit
import Foundation

// MARK: - Data Structures & Helpers

// Stores information for a single application.
// The JSON output will be an array of these objects at the root level.
struct AppInfo: Codable, Hashable {
    let id: String // A unique ID for each app
    let name: String
    let path: String
    let icon_path: String? // Filename of the saved PNG icon (e.g., "AppName.png")

    // Initialize with a default UUID string if not provided, for new apps or when decoding
    init(id: String = UUID().uuidString, name: String, path: String, icon_path: String?) {
        self.id = id
        self.name = name
        self.path = path
        self.icon_path = icon_path
    }
}

extension NSImage {
    var pngData: Data? {
        guard let tiffRepresentation = self.tiffRepresentation,
              let bitmapImage = NSBitmapImageRep(data: tiffRepresentation) else {
            return nil
        }
        return bitmapImage.representation(using: .png, properties: [:])
    }
}

struct StderrOutputStream: TextOutputStream {
    func write(_ string: String) {
        let line = string + "\n"
        FileHandle.standardError.write(Data(line.utf8))
    }
}
var standardError = StderrOutputStream()

// MARK: - Core Logic

/// Scans the system very quickly for application paths only.
func getCurrentAppPaths() -> Set<String> {
    let fileManager = FileManager.default
    var currentAppPaths = Set<String>()
    let applicationDirectories = fileManager.urls(for: .applicationDirectory, in: .allDomainsMask)

    for directoryURL in applicationDirectories {
        guard let appURLs = try? fileManager.contentsOfDirectory(
            at: directoryURL,
            includingPropertiesForKeys: [],
            options: [.skipsHiddenFiles, .skipsPackageDescendants]
        ) else { continue }
        
        for appURL in appURLs where appURL.pathExtension == "app" {
            currentAppPaths.insert(appURL.path)
        }
    }
    return currentAppPaths
}

/// Reads app data from a JSON file into a Dictionary for fast lookups.
/// Handles decoding AppInfo objects that might not yet have an 'id' by assigning one.
func getAppsFromFile(from fileURL: URL) -> [String: AppInfo] {
    guard let data = try? Data(contentsOf: fileURL) else {
        print("Could not read file at \(fileURL.path). Assuming it's a new file or empty.", to: &standardError)
        return [:]
    }

    let decoder = JSONDecoder()
    do {
        var appsFromFile = try decoder.decode([AppInfo].self, from: data)
        
        // Handle migration for existing entries without an 'id'
        // This iterates through the decoded apps and ensures each has an ID.
        // If an ID is missing (e.g., from an older JSON file), a new one is generated.
        for i in 0..<appsFromFile.count {
            if appsFromFile[i].id.isEmpty { // Assuming an empty string implies missing ID
                appsFromFile[i] = AppInfo(id: UUID().uuidString, name: appsFromFile[i].name, path: appsFromFile[i].path, icon_path: appsFromFile[i].icon_path)
                print("Assigned new ID to \(appsFromFile[i].name) during migration.", to: &standardError)
            }
        }
        
        return Dictionary(uniqueKeysWithValues: appsFromFile.map { ($0.path, $0) })
    } catch {
        print("Error decoding file at \(fileURL.path): \(error). Assuming it's a new file or invalid format.", to: &standardError)
        return [:]
    }
}

/// Generates AppInfo and saves the icon to a specified directory.
func generateAppInfo(for appPath: String, savingIconsTo iconDirectoryPath: String) -> AppInfo? {
    let appURL = URL(fileURLWithPath: appPath)
    var appName: String
    
    if let bundle = Bundle(url: appURL),
       let name = bundle.object(forInfoDictionaryKey: "CFBundleDisplayName") as? String ?? bundle.object(forInfoDictionaryKey: "CFBundleName") as? String {
        appName = name
    } else {
        appName = appURL.deletingPathExtension().lastPathComponent
    }
    
    let iconImage = NSWorkspace.shared.icon(forFile: appPath)
    var savedicon_path: String? = nil
    
    if let pngData = iconImage.pngData {
        // Sanitize filename to be safe for file system
        let safeFilename = appName.replacingOccurrences(of: "[^a-zA-Z0-9-]", with: "_", options: .regularExpression) + ".png"
        let destinationURL = URL(fileURLWithPath: iconDirectoryPath).appendingPathComponent(safeFilename)
        
        do {
            try pngData.write(to: destinationURL)
            savedicon_path = safeFilename
        } catch {
            print("Error: Could not save icon for \(appName) to \(destinationURL.path). \(error)", to: &standardError)
        }
    }
    
    // A unique ID will be automatically generated by the AppInfo initializer
    return AppInfo(name: appName, path: appPath, icon_path: savedicon_path)
}


/// The main function to perform the update.
func updateAppList() {
    guard CommandLine.arguments.count > 2 else {
        print("Usage: \(CommandLine.arguments[0]) /path/to/apps.json /path/to/icons_dir", to: &standardError)
        return
    }
    
    let filePath = CommandLine.arguments[1]
    let iconDirPath = CommandLine.arguments[2]
    let fileURL = URL(fileURLWithPath: filePath)
    let fileManager = FileManager.default
    
    do {
        try fileManager.createDirectory(atPath: iconDirPath, withIntermediateDirectories: true, attributes: nil)
    } catch {
        print("Fatal Error: Could not create icon directory at \(iconDirPath). \(error)", to: &standardError)
        return
    }
    
    print("Reading existing app list from: \(filePath)", to: &standardError)
    var finalApps = getAppsFromFile(from: fileURL)
    
    print("Scanning for application paths...", to: &standardError)
    let pathsOnSystem = getCurrentAppPaths()
    let pathsFromFile = Set(finalApps.keys)
    
    let newAppPaths = pathsOnSystem.subtracting(pathsFromFile)
    let deletedAppPaths = pathsFromFile.subtracting(pathsOnSystem)
    
    if newAppPaths.isEmpty && deletedAppPaths.isEmpty {
        print("No changes detected. Application list is up-to-date.", to: &standardError)
        return
    }
    
    // Process deletions
    for path in deletedAppPaths {
        if let deletedAppInfo = finalApps[path], let iconFilenameToDelete = deletedAppInfo.icon_path {
            let fullIconPath = URL(fileURLWithPath: iconDirPath).appendingPathComponent(iconFilenameToDelete).path
            
            do {
                try fileManager.removeItem(atPath: fullIconPath)
                print("Deleted cached icon: \(fullIconPath)", to: &standardError)
            } catch {
                print("Info: Could not delete icon for \(deletedAppInfo.name) at \(fullIconPath). It may have already been removed. \(error)", to: &standardError)
            }
        }
        finalApps.removeValue(forKey: path)
        let appName = URL(fileURLWithPath: path).deletingPathExtension().lastPathComponent
        print("Removing deleted app: \(appName)", to: &standardError)
    }
    
    // Process additions
    for path in newAppPaths {
        let appName = URL(fileURLWithPath: path).deletingPathExtension().lastPathComponent
        print("Processing new app: \(appName)...", to: &standardError)
        if let newAppInfo = generateAppInfo(for: path, savingIconsTo: iconDirPath) {
            finalApps[path] = newAppInfo
        }
    }
    
    // Write the updated list back to the file
    let encoder = JSONEncoder()
    encoder.outputFormatting = .prettyPrinted
    
    do {
        // Create the sorted array of apps to be the root JSON object.
        let sortedApps = finalApps.values.sorted { $0.name.lowercased() < $1.name.lowercased() }
        
        // Encode the array directly.
        let jsonData = try encoder.encode(sortedApps)
        try jsonData.write(to: fileURL)
        print("Successfully updated the file at \(filePath). Found \(newAppPaths.count) new and \(deletedAppPaths.count) deleted app(s).", to: &standardError)
    } catch {
        print("Fatal Error: Could not encode or write updated JSON to file. \(error)", to: &standardError)
    }
}

// Execute the main function.
updateAppList()